<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">pre {
  background-color: #F3F3F3;
  border: solid 1px #CCC;
  padding: 5px 10px;
  font-family: 'Menlo', 'Courier New', 'Terminal', monospace;
}
.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #808080 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0040D0 } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.il { color: #666666 } /* Literal.Number.Integer.Long */</style>
</head>
<body>
<h1>序幕</h1>
<blockquote>
<p>是风格区分了好和伟大。 <br>
-- Bozhidar Batsov</p>
</blockquote>
<p>作为 Ruby 开发者，有一件总是令我烦心的事 — Python 开发者有一份好的编程风格参考指南(<a href="http://www.python.org/dev/peps/pep-0008/">PEP-8</a>) 而我们永远没有一份官方指南，一份记录 Ruby 编程风格及最佳实践的指南。而我们确信风格很重要。我也相信这些好家伙们，像我们这些 Ruby 开发者，应该可以自己写一份这个梦寐以求的文档。</p>

<p>这份指南开始是作为我们公司内部 Ruby 编程指南(由我所写的)。进行到某个部分时，我决定要把我的成果贡献给广大的 Ruby 社区，而且这个世界需要从另一个公司内部的一点帮助。然而这个世界也可以从由社区制定及策动的一系列 Ruby 编程惯例、实践及风格中受益。</p>

<p>在开始写这份指南时，我收到世界上很多优秀 Ruby 社区用户们的反馈。感谢所有的建议及帮助！我们同心协力创造一个能够让每一个 Ruby 开发者受益的资源。</p>

<p>顺道一提，如果你对 Rails 感兴趣，你可以看看这份互补的 <a href="https://github.com/bbatsov/rails-style-guide">Ruby on Rails 3 风格指南</a>。</p>

<h1>Ruby 风格指南</h1>

<p>这份 Ruby 风格指南向你推荐现实世界中的最佳实践，Ruby 程序员如何写出可被别的 Ruby 程序员维护的代码。一份风格指南反映出现实世界中的用法，并带有一个理想，避免已经公认是危险的事物不被人继续使用 –– 不管看起来是多么的好。</p>

<p>本指南依照相关规则分成数个小节。我尽力在规则后面说明理由（如果省略的话，我相信理由是显而易见的）。</p>

<p>我没有想到所有的规则 — 他们大致上是基于，我作为一个专业软体工程师的广泛生涯，从 Ruby 社区成员所得到的反馈及建议，和数个高度评价的 Ruby 编程资源，像是 <a href="http://pragprog.com/book/ruby4/programming-ruby-1-9-2-0">"Programming Ruby 1.9"</a> 以及 <a href="http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177">"The Ruby Programming Language"</a>。</p>

<p>本指南仍在完善中 — 某些规则缺乏实例，某些规则没有例子来清楚地演示它们。在最后交付时，将会解决这些议题 — 现在就先把它们记在心理吧。</p>

<p>你可以使用 <a href="https://github.com/TechnoGate/transmuter">Transmuter</a> 来产生本指南的一份 PDF 或 HTML 复本。</p>

<p><a href="https://github.com/bbatsov/rubocop">rubocop</a> 项目会自动检查你的 Ruby 代码是否符合这份 Ruby 风格指南。目前这个项目尚有许多功能缺漏，不足以被正式地使用，欢迎有志之士协助改进。</p>

<p>本指南被翻译成下列语言：</p>

<ul>
<li><a href="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md">简体中文</a></li>
<li><a href="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhTW.md">繁體中文</a></li>
<li><a href="https://github.com/porecreat/ruby-style-guide/blob/master/README-frFR.md">法文</a></li>
</ul>
<h2>目录</h2>

<ul>
<li><a href="#-2">源代码排版</a></li>
<li><a href="#-3">语法</a></li>
<li><a href="#-4">命名</a></li>
<li>
<a href="#-5">注释</a>

<ul>
<li><a href="#-6">注解</a></li>
</ul>
</li>
<li><a href="#-7">类别</a></li>
<li><a href="#-8">异常</a></li>
<li><a href="#-9">集合</a></li>
<li><a href="#-10">字符串</a></li>
<li><a href="#-11">正则表达式</a></li>
<li><a href="#-12">百分比字面</a></li>
<li><a href="#-13">元编程</a></li>
<li><a href="#-14">其它</a></li>
<li><a href="#-15">工具</a></li>
</ul>
<h2>源代码排版</h2>
<blockquote>
<p>几乎每人都深信，每一个除了自己的风格都又丑又难读。把 "除了自己的" 拿掉，他们或许是对的...<br>
-- Jerry Coffin (论缩排)</p>
</blockquote>
<ul>
<li>使用 <code>UTF-8</code> 作为源文件的编码。</li>
<li>
<p>每个缩排层级使用两个 <strong>空格</strong>。不要使用 Hard Tabs。</p>

<div class="highlight">
<pre><span class="c1"># å·® - åä¸ªç©ºæ ¼</span>
<span class="k">def</span> <span class="nf">some_method</span>
    <span class="n">do_something</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">def</span> <span class="nf">some_method</span>
  <span class="n">do_something</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>使用 Unix 风格的行编码(BSD/Solaris/Linux/OSX 的用户不用担心，Windows 用户要格外小心。)</p>

<ul>
<li>如果你使用 Git ，你也许会想加入下面这个配置，来保护你的项目不被 Windows 的行编码侵入：</li>
</ul>
<div class="highlight">
<pre>  <span class="nv">$ </span>git config --global core.autocrlf <span class="nb">true</span>
</pre>
</div>
</li>
<li>
<p>不要使用<code>;</code>来隔开语句和表达式。推论 - 每一行使用一条语句。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="nb">puts</span> <span class="s1">'foobar'</span><span class="p">;</span> <span class="c1"># ä¸å¿è¦çåå·</span>

<span class="nb">puts</span> <span class="s1">'foo'</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">'bar'</span> <span class="c1"># åä¸è¡éæä¸¤ä¸ªè¡¨è¾¾å¼</span>

<span class="c1"># å¥½</span>
<span class="nb">puts</span> <span class="s1">'foobar'</span>

<span class="nb">puts</span> <span class="s1">'foo'</span>
<span class="nb">puts</span> <span class="s1">'bar'</span>

<span class="nb">puts</span> <span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'bar'</span> <span class="c1"># ç¹å«çï¼è¿ä¸ªéç¨äºputs</span>
</pre>
</div>
</li>
<li>
<p>对于没有成员的类，尽可能使用单行类定义。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">class</span> <span class="nc">FooError</span> <span class="o">&lt;</span> <span class="no">StandardError</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">class</span> <span class="nc">FooError</span> <span class="o">&lt;</span> <span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>避免使用单行方法。尽管它们在圈子里有那么一点点流行，但是它们的定义语法有一些诡异的特性导致使用它们时并不尽如人意。无论如何 - 一个单行方法里的表达式不应该多于 1 个。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">def</span> <span class="nf">too_much</span><span class="p">;</span> <span class="n">something</span><span class="p">;</span> <span class="n">something_else</span><span class="p">;</span> <span class="k">end</span>

<span class="c1"># åå¼ºå¯ä»¥ - æ³¨æç¬¬ä¸ä¸ª ; æ¯å¿éç</span>
<span class="k">def</span> <span class="nf">no_braces_method</span><span class="p">;</span> <span class="n">body</span> <span class="k">end</span>

<span class="c1"># åå¼ºå¯ä»¥ - æ³¨æç¬¬äºä¸ª ; æ¯å¯éç</span>
<span class="k">def</span> <span class="nf">no_braces_method</span><span class="p">;</span> <span class="n">body</span><span class="p">;</span> <span class="k">end</span>

<span class="c1"># åå¼ºå¯ä»¥ - è¯­æ³ä¸æ­£ç¡®ï¼ä½æ¯æ²¡æ ; è®©å®æäºé¾è¯»</span>
<span class="k">def</span> <span class="nf">some_method</span><span class="p">()</span> <span class="n">body</span> <span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">def</span> <span class="nf">some_method</span>
  <span class="n">body</span>
<span class="k">end</span>
</pre>
</div>


<p>这个规则的一个例外是空方法。</p>

<div class="highlight">
<pre><span class="c1"># å¥½</span>
<span class="k">def</span> <span class="nf">no_op</span><span class="p">;</span> <span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>使用空格来围绕操作符，逗号 <code>,</code> 、冒号 <code>:</code> 及分号 <code>;</code> 之后，围绕在 <code>{</code> 和 <code>}</code> 之前。
空格可能对（大部分）Ruby 直译器来说是无关紧要的，但正确的使用是写出可读性高的代码的关键。</p>

<div class="highlight">
<pre><span class="n">sum</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">?</span> <span class="kp">true</span> <span class="p">:</span> <span class="kp">false</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">'Hi'</span>
<span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">].</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">e</span> <span class="p">}</span>
</pre>
</div>


<p>（针对操作符）唯一的例外是当使用指数操作符时：</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="n">c</span> <span class="o">**</span> <span class="mi">2</span>

<span class="c1"># å¥½</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span>
</pre>
</div>


<p><code>{</code> 和 <code>}</code> 需要额外说明，因为他们是用在块（block）、
哈希字面量（hash literals），以及嵌入字符串的表达式中。
对于哈希字面量来说，两种风格都是可接受的。</p>

<div class="highlight">
<pre><span class="c1"># å¥½ - { ä¹åå }ä¹åæç©ºæ ¼</span>
<span class="p">{</span> <span class="n">one</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span>

<span class="c1"># å¥½ - { ä¹åå }ä¹åæ²¡æç©ºæ ¼</span>
<span class="p">{</span><span class="n">one</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
</pre>
</div>


<p>第一个种风格稍微更具可读性（而且有争议的是，一般在Ruby社区里更受欢迎）。
第二种风格具有可为块和哈希字面量添加可视化的差别的优点。
无论你选哪一种都行 - 但是最好保持一致。</p>

<p>至于嵌入表达式（embedded expressions），这儿也有两个可接受的选择：</p>

<div class="highlight">
<pre><span class="c1"># å¥½ - æ²¡æç©ºæ ¼</span>
<span class="s2">"string</span><span class="si">#{</span><span class="n">expr</span><span class="si">}</span><span class="s2">"</span>

<span class="c1"># å¯ä»¥ - æ´å·å¯è¯»æ§ï¼æäºäºè®®ï¼</span>
<span class="s2">"string</span><span class="si">#{</span> <span class="n">expr</span> <span class="si">}</span><span class="s2">"</span>
</pre>
</div>


<p>第一种风格极为流行，一般其他人都会建议你坚持这种风格。
另一方面来说，第二种风格有些更具可读性（虽然颇具争议）。
正如哈系那样 - 选一种风格并且保持一致。</p>
</li>
<li>
<p>不要有空格在 <code>(</code> 、 <code>[</code> 之后，或 <code>]</code> 、 <code>)</code> 之前。</p>

<div class="highlight">
<pre><span class="n">some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="n">other</span>
<span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">].</span><span class="n">length</span>
</pre>
</div>
</li>
<li>
<p>把 <code>when</code> 跟 <code>case</code> 缩排在同一层。我知道很多人不同意这一点，但这是 "The Ruby Programming Language" 及 "Programming Ruby" 所使用的风格。</p>

<div class="highlight">
<pre><span class="k">case</span>
<span class="k">when</span> <span class="n">song</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">'Misty'</span>
  <span class="nb">puts</span> <span class="s1">'Not again!'</span>
<span class="k">when</span> <span class="n">song</span><span class="o">.</span><span class="n">duration</span> <span class="o">&gt;</span> <span class="mi">120</span>
  <span class="nb">puts</span> <span class="s1">'Too long!'</span>
<span class="k">when</span> <span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">hour</span> <span class="o">&gt;</span> <span class="mi">21</span>
  <span class="nb">puts</span> <span class="s2">"It's too late"</span>
<span class="k">else</span>
  <span class="n">song</span><span class="o">.</span><span class="n">play</span>
<span class="k">end</span>

<span class="n">kind</span> <span class="o">=</span> <span class="k">case</span> <span class="n">year</span>
       <span class="k">when</span> <span class="mi">1850</span><span class="o">.</span><span class="n">.</span><span class="mi">1889</span> <span class="k">then</span> <span class="s1">'Blues'</span>
       <span class="k">when</span> <span class="mi">1890</span><span class="o">.</span><span class="n">.</span><span class="mi">1909</span> <span class="k">then</span> <span class="s1">'Ragtime'</span>
       <span class="k">when</span> <span class="mi">1910</span><span class="o">.</span><span class="n">.</span><span class="mi">1929</span> <span class="k">then</span> <span class="s1">'New Orleans Jazz'</span>
       <span class="k">when</span> <span class="mi">1930</span><span class="o">.</span><span class="n">.</span><span class="mi">1939</span> <span class="k">then</span> <span class="s1">'Swing'</span>
       <span class="k">when</span> <span class="mi">1940</span><span class="o">.</span><span class="n">.</span><span class="mi">1950</span> <span class="k">then</span> <span class="s1">'Bebop'</span>
       <span class="k">else</span> <span class="s1">'Jazz'</span>
       <span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>在 <code>def</code> 之间使用空行，并且把方法分成合乎逻辑的段落。</p>

<div class="highlight">
<pre><span class="k">def</span> <span class="nf">some_method</span>
  <span class="n">data</span> <span class="o">=</span> <span class="kp">initialize</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

  <span class="n">data</span><span class="o">.</span><span class="n">manipulate!</span>

  <span class="n">data</span><span class="o">.</span><span class="n">result</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">some_method</span>
  <span class="n">result</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>当给方法的参数赋默认值时，在 <code>=</code> 两边使用空格：</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="n">arg1</span><span class="o">=</span><span class="ss">:default</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="n">arg3</span><span class="o">=[]</span><span class="p">)</span>
  <span class="c1"># åä¸äºä»»å¡...</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="n">arg1</span> <span class="o">=</span> <span class="ss">:default</span><span class="p">,</span> <span class="n">arg2</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">arg3</span> <span class="o">=</span> <span class="o">[]</span><span class="p">)</span>
  <span class="c1"># åä¸äºä»»å¡...</span>
<span class="k">end</span>
</pre>
</div>


<p>虽然几本 Ruby 书建议用第一个风格，不过第二个风格在实践中更为常见（并可争议地可读性更高一点）。</p>
</li>
<li>
<p>避免在不需要的时候使用行继续符 (\) 。实际编码时，尽力避免使用行继续符。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">\</span>
         <span class="mi">2</span>

<span class="c1"># å¥½ (ä½æ¯ä»ç¶ä¸å°ç)</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">\</span>
         <span class="o">-</span> <span class="mi">2</span>
</pre>
</div>
</li>
<li>
<p>当一个链式方法调用需要在另一行继续时，将 <code>.</code> 放在第二行</p>

<div class="highlight">
<pre><span class="c1"># å·® - ä¸ºäºçè§£ç¬¬äºè¡éè¦å»æ¥éç¬¬ä¸è¡</span>
<span class="n">one</span><span class="o">.</span><span class="n">two</span><span class="o">.</span><span class="n">three</span><span class="o">.</span>
  <span class="n">four</span>

<span class="c1"># å¥½ - ç¬¬äºè¡å¨åä»ä¹ç«å»åå¾å¾æ¸æ°</span>
<span class="n">one</span><span class="o">.</span><span class="n">two</span><span class="o">.</span><span class="n">three</span>
  <span class="o">.</span><span class="n">four</span>
</pre>
</div>
</li>
<li>
<p>当一个方法呼叫的参数扩展超过一行时，排列它们。</p>

<div class="highlight">
<pre><span class="c1"># ä¸å¼å§ï¼ä¸è¡å¤ªé¿ï¼</span>
<span class="k">def</span> <span class="nf">send_mail</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
  <span class="no">Mailer</span><span class="o">.</span><span class="n">deliver</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="s1">'bob@example.com'</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="s1">'us@example.com'</span><span class="p">,</span> <span class="n">subject</span><span class="p">:</span> <span class="s1">'Important message'</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># å·®ï¼ä¸è¬çç¼©æï¼</span>
<span class="k">def</span> <span class="nf">send_mail</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
  <span class="no">Mailer</span><span class="o">.</span><span class="n">deliver</span><span class="p">(</span>
    <span class="n">to</span><span class="p">:</span> <span class="s1">'bob@example.com'</span><span class="p">,</span>
    <span class="n">from</span><span class="p">:</span> <span class="s1">'us@example.com'</span><span class="p">,</span>
    <span class="n">subject</span><span class="p">:</span> <span class="s1">'Important message'</span><span class="p">,</span>
    <span class="n">body</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># å·®ï¼ä¸¤åç¼©æï¼</span>
<span class="k">def</span> <span class="nf">send_mail</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
  <span class="no">Mailer</span><span class="o">.</span><span class="n">deliver</span><span class="p">(</span>
      <span class="n">to</span><span class="p">:</span> <span class="s1">'bob@example.com'</span><span class="p">,</span>
      <span class="n">from</span><span class="p">:</span> <span class="s1">'us@example.com'</span><span class="p">,</span>
      <span class="n">subject</span><span class="p">:</span> <span class="s1">'Important message'</span><span class="p">,</span>
      <span class="n">body</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">def</span> <span class="nf">send_mail</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
  <span class="no">Mailer</span><span class="o">.</span><span class="n">deliver</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="s1">'bob@example.com'</span><span class="p">,</span>
                 <span class="n">from</span><span class="p">:</span> <span class="s1">'us@example.com'</span><span class="p">,</span>
                 <span class="n">subject</span><span class="p">:</span> <span class="s1">'Important message'</span><span class="p">,</span>
                 <span class="n">body</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>长的常量数字添加下划线来改善可读性</p>

<div class="highlight">
<pre><span class="c1"># å·® - æå ä¸ªé¶ï¼</span>
<span class="n">num</span> <span class="o">=</span> <span class="mi">1000000</span>

<span class="c1"># å¥½ - æ´å®¹æè¢«äººèè§£æã</span>
<span class="n">num</span> <span class="o">=</span> <span class="mi">1_000_000</span>
</pre>
</div>
</li>
<li><p>使用 RDoc 以及它的惯例来撰写 API 文档。不要在注解区块及 <code>def</code> 之前放一个空行。</p></li>
<li><p>将每一行最多限制在 80 个字符。</p></li>
<li><p>避免尾随的空白。</p></li>
<li>
<p>不要使用区块注释。它们不能由空白引导，并且不如普通注释容易辨认。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="o">==</span> <span class="k">begin</span>
<span class="err">ä¸è¡æ³¨é</span>
<span class="err">å¦ä¸è¡æ³¨é</span>
<span class="o">==</span> <span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="c1"># ä¸è¡æ³¨é</span>
<span class="c1"># å¦ä¸è¡æ³¨é</span>
</pre>
</div>
</li>
</ul>
<h2>语法</h2>

<ul>
<li>
<p>使用 <code>::</code> 只能引用常量（包括类和模块）。永远不要使用 <code>::</code> 来调用方法。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="no">SomeClass</span><span class="o">::</span><span class="n">some_method</span>
<span class="n">some_object</span><span class="o">::</span><span class="n">some_method</span>

<span class="c1"># å¥½</span>
<span class="no">SomeClass</span><span class="o">.</span><span class="n">some_method</span>
<span class="n">some_object</span><span class="o">.</span><span class="n">some_method</span>
<span class="no">SomeModule</span><span class="o">::</span><span class="no">SomeClass</span><span class="o">::</span><span class="no">SOME_CONST</span>
</pre>
</div>
</li>
<li>
<p>使用 <code>def</code> 时，当有参数时使用括号。当方法不接受任何参数时，省略括号。</p>

<div class="highlight">
<pre> <span class="k">def</span> <span class="nf">some_method</span>
   <span class="c1"># æ­¤å¤çç¥æ¹æ³ä½</span>
 <span class="k">end</span>

 <span class="k">def</span> <span class="nf">some_method_with_arguments</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
   <span class="c1"># æ­¤å¤çç¥æ¹æ³ä½</span>
 <span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>永远不要使用 <code>for</code> ，除非你很清楚为什么。大部分情况应该使用迭代器来取代。 <code>for</code> 是由 <code>each</code> 所实现的（所以你加入了一层的迂回），但出乎意料的是 — <code>for</code> 并没有包含一个新的作用域(不像是 <code>each</code> ）而在这个区块中定义的变量将会被外部所看到。</p>

<div class="highlight">
<pre><span class="n">arr</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>

<span class="c1"># å·®</span>
<span class="k">for</span> <span class="n">elem</span> <span class="k">in</span> <span class="n">arr</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="n">elem</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="n">arr</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">elem</span> <span class="p">}</span>
</pre>
</div>
</li>
<li>
<p>永远不要在多行的 <code>if/unless</code> 使用 <code>then</code></p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">if</span> <span class="n">some_condition</span> <span class="k">then</span>
  <span class="c1"># æ­¤å¤çç¥è¯­å¥ä½</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">if</span> <span class="n">some_condition</span>
  <span class="c1"># æ­¤å¤çç¥è¯­å¥ä½</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>倾向使用三元操作符 <code>? :</code> 而不是 <code>if/then/else/end</code> 结构，它更为常见及更精准。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">result</span> <span class="o">=</span> <span class="k">if</span> <span class="n">some_condition</span> <span class="k">then</span> <span class="n">something</span> <span class="k">else</span> <span class="n">something_else</span> <span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">some_condition</span> <span class="p">?</span> <span class="n">something</span> <span class="p">:</span> <span class="n">something_else</span>
</pre>
</div>
</li>
<li>
<p>使用一个表达式给一个三元操作符的分支。这也意味着三元操作符不要嵌套。嵌套情况使用 <code>if/else</code> 结构。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">some_condition</span> <span class="p">?</span> <span class="p">(</span><span class="n">nested_condition</span> <span class="p">?</span> <span class="n">nested_something</span> <span class="p">:</span> <span class="n">nested_something_else</span><span class="p">)</span> <span class="p">:</span> <span class="n">something_else</span>

<span class="c1"># å¥½</span>
<span class="k">if</span> <span class="n">some_condition</span>
  <span class="n">nested_condition</span> <span class="p">?</span> <span class="n">nested_something</span> <span class="p">:</span> <span class="n">nested_something_else</span>
<span class="k">else</span>
  <span class="n">something_else</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>永远不要使用 <code>if x: ...</code> — 它已经在 Ruby 1.9 被移除了。使用三元操作符来取代。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">result</span> <span class="o">=</span> <span class="k">if</span> <span class="n">some_condition</span><span class="p">:</span> <span class="n">something</span> <span class="k">else</span> <span class="n">something_else</span> <span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">some_condition</span> <span class="p">?</span> <span class="n">something</span> <span class="p">:</span> <span class="n">something_else</span>
</pre>
</div>
</li>
<li><p>永远不要使用 <code>if x: ...</code> 使用三元操作符来取代。</p></li>
<li><p>一行的情况使用 <code>when x then ...</code>。替代方案的语法 <code>when x: ...</code> 已经在 Ruby 1.9 被移除了。</p></li>
<li><p>永远不要使用 <code>when x: ...</code>。参考前一个规则。</p></li>
<li>
<p>使用 <code>!</code> 替代 <code>not</code>.</p>

<div class="highlight">
<pre><span class="c1"># å·® - å ä¸ºæä½ç¬¦æä¼åçº§ï¼éè¦ç¨æ¬å·ã</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">something</span><span class="p">)</span>

<span class="c1"># å¥½</span>
<span class="n">x</span> <span class="o">=</span> <span class="o">!</span><span class="n">something</span>
</pre>
</div>
</li>
<li>
<p>布尔表达式使用 <code>&amp;&amp;/||</code>，控制流程使用 <code>and/or</code>。 （经验法则：如果你需要使用外部括号，你正在使用错误的操作符。）</p>

<div class="highlight">
<pre><span class="c1"># å¸å°è¡¨è¾¾å¼</span>
<span class="k">if</span> <span class="n">some_condition</span> <span class="o">&amp;&amp;</span> <span class="n">some_other_condition</span>
  <span class="n">do_something</span>
<span class="k">end</span>

<span class="c1"># æ§å¶æµç¨</span>
<span class="n">document</span><span class="o">.</span><span class="n">saved?</span> <span class="ow">or</span> <span class="n">document</span><span class="o">.</span><span class="n">save!</span>
</pre>
</div>
</li>
<li><p>避免多行的 <code>? :</code>（三元操作符）；使用 <code>if/unless</code> 来取代。</p></li>
<li>
<p>偏爱 <code>if/unless</code> 修饰符当你有单行的主体。另一个好的方法是使用控制流程的 <code>and/or</code>。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">if</span> <span class="n">some_condition</span>
  <span class="n">do_something</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="n">do_something</span> <span class="k">if</span> <span class="n">some_condition</span>

<span class="c1"># å¦ä¸ä¸ªå¥½æ¹æ³</span>
<span class="n">some_condition</span> <span class="ow">and</span> <span class="n">do_something</span>
</pre>
</div>
</li>
<li>
<p>否定条件偏爱 <code>unless</code> 优于 <code>if</code>（或是控制流程 <code>or</code>）。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">do_something</span> <span class="k">if</span> <span class="o">!</span><span class="n">some_condition</span>

<span class="c1"># å¥½</span>
<span class="n">do_something</span> <span class="k">unless</span> <span class="n">some_condition</span>

<span class="c1"># å¦ä¸ä¸ªå¥½æ¹æ³</span>
<span class="n">some_condition</span> <span class="ow">or</span> <span class="n">do_something</span>
</pre>
</div>
</li>
<li>
<p>永远不要使用 <code>unless</code> 搭配 <code>else</code> 。将它们改写成肯定条件。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">unless</span> <span class="n">success?</span>
  <span class="nb">puts</span> <span class="s1">'failure'</span>
<span class="k">else</span>
  <span class="nb">puts</span> <span class="s1">'success'</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">if</span> <span class="n">success?</span>
  <span class="nb">puts</span> <span class="s1">'success'</span>
<span class="k">else</span>
  <span class="nb">puts</span> <span class="s1">'failure'</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>不要使用括号围绕 <code>if/unless/while</code> 的条件式，除非这条件包含了一个赋值（见下面使用 <code>=</code> （一个赋值）的返回值）。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
  <span class="c1"># æ­¤å¤çç¥è¯­å¥ä½</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">10</span>
  <span class="c1"># æ­¤å¤çç¥è¯­å¥ä½</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="n">next_value</span><span class="p">)</span>
  <span class="c1"># æ­¤å¤çç¥è¯­å¥ä½</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>当你有单行主体时，偏爱使用 <code>while/until</code> 修饰符。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">while</span> <span class="n">some_condition</span>
  <span class="n">do_something</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="n">do_something</span> <span class="k">while</span> <span class="n">some_condition</span>
</pre>
</div>
</li>
<li>
<p>负面条件倾向使用 <code>until</code> 而不是 <code>while</code> 。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">do_something</span> <span class="k">while</span> <span class="o">!</span><span class="n">some_condition</span>

<span class="c1"># å¥½</span>
<span class="n">do_something</span> <span class="k">until</span> <span class="n">some_condition</span>
</pre>
</div>
</li>
<li><p>为循环后测试使用 Kernel#loop 搭配 break 而不是 <code>begin/end/until</code> 或者 <code>begin/end/while</code>。</p></li>
</ul>
<div class="highlight">
<pre>   <span class="c1"># å·®</span>
   <span class="k">begin</span>
     <span class="nb">puts</span> <span class="n">val</span>
     <span class="n">val</span> <span class="o">+=</span> <span class="mi">1</span>
   <span class="k">end</span> <span class="k">while</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span>

   <span class="c1"># å¥½</span>
   <span class="kp">loop</span> <span class="k">do</span>
     <span class="nb">puts</span> <span class="n">val</span>
     <span class="n">val</span> <span class="o">+=</span> <span class="mi">1</span>
     <span class="k">break</span> <span class="k">unless</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span>
   <span class="k">end</span>
</pre>
</div>


<ul>
<li>
<p>忽略围绕方法参数的括号，如内部 DSL (如：Rake, Rails, RSpec)，Ruby 中带有 "关键字" 状态的方法（如：<code>attr_reader</code>, <code>puts</code>）以及属性存取方法。所有其他的方法呼叫使用括号围绕参数。</p>

<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">attr_reader</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:age</span>

  <span class="c1"># å¿½ç¥</span>
<span class="k">end</span>

<span class="n">temperance</span> <span class="o">=</span> <span class="no">Person</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">'Temperance'</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">temperance</span><span class="o">.</span><span class="n">name</span>

<span class="nb">puts</span> <span class="n">temperance</span><span class="o">.</span><span class="n">age</span>

<span class="n">x</span> <span class="o">=</span> <span class="no">Math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="n">array</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre>
</div>
</li>
<li>
<p>单行区块倾向使用 <code>{...}</code> 而不是 <code>do..end</code>。多行区块避免使用 <code>{...}</code>（多行串连总是​​丑陋）。在 <code>do...end</code> 、 "控制流程" 及 "方法定义" ，永远使用 <code>do...end</code> （如 Rakefile 及某些 DSL）。串连时避免使用 <code>do...end</code>。</p>

<div class="highlight">
<pre><span class="n">names</span> <span class="o">=</span> <span class="o">[</span><span class="s1">'Bozhidar'</span><span class="p">,</span> <span class="s1">'Steve'</span><span class="p">,</span> <span class="s1">'Sarah'</span><span class="o">]</span>

<span class="c1"># å·®</span>
<span class="n">names</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="nb">name</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="n">names</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">puts</span> <span class="nb">name</span> <span class="p">}</span>

<span class="c1"># å·®</span>
<span class="n">names</span><span class="o">.</span><span class="n">select</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
  <span class="nb">name</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s1">'S'</span><span class="p">)</span>
<span class="k">end</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="o">.</span><span class="n">upcase</span> <span class="p">}</span>

<span class="c1"># å¥½</span>
<span class="n">names</span><span class="o">.</span><span class="n">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="o">.</span><span class="n">start_with?</span><span class="p">(</span><span class="s1">'S'</span><span class="p">)</span> <span class="p">}</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="o">.</span><span class="n">upcase</span> <span class="p">}</span>
</pre>
</div>


<p>某些人会争论多行串连时，使用 <code>{...}</code> 看起来还可以，但他们应该扪心自问— 这样代码真的可读吗？难道不能把区块内容取出来放到小巧的方法里吗？</p>
</li>
<li>
<p>避免在不需要控制流程的场合时使用 <code>return</code> 。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="n">some_arr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">some_arr</span><span class="o">.</span><span class="n">size</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="n">some_arr</span><span class="p">)</span>
  <span class="n">some_arr</span><span class="o">.</span><span class="n">size</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>避免在不需要的情况使用 <code>self</code> 。（只有在调用一个 self write 访问器时会需要用到。）</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">def</span> <span class="nf">ready?</span>
  <span class="k">if</span> <span class="nb">self</span><span class="o">.</span><span class="n">last_reviewed_at</span> <span class="o">&gt;</span> <span class="nb">self</span><span class="o">.</span><span class="n">last_updated_at</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">worker</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="nb">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="ss">:in_progress</span>
  <span class="k">end</span>
  <span class="nb">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="ss">:verified</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">def</span> <span class="nf">ready?</span>
  <span class="k">if</span> <span class="n">last_reviewed_at</span> <span class="o">&gt;</span> <span class="n">last_updated_at</span>
    <span class="n">worker</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="n">status</span> <span class="o">=</span> <span class="ss">:in_progress</span>
  <span class="k">end</span>
  <span class="n">status</span> <span class="o">==</span> <span class="ss">:verified</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>避免使用带有局部变量的 shadowing 方法，除非它们彼此相等。</p>

<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Foo</span>
  <span class="kp">attr_accessor</span> <span class="ss">:options</span>

  <span class="c1"># ok</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>
    <span class="c1"># æ­¤å¤ options å self.options é½æ¯ç­ä»·ç</span>
  <span class="k">end</span>

  <span class="c1"># å·®</span>
  <span class="k">def</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="k">unless</span> <span class="n">options</span><span class="o">[</span><span class="ss">:when</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:later</span>
      <span class="n">output</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">options</span><span class="o">[</span><span class="ss">:message</span><span class="o">]</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># å¥½</span>
  <span class="k">def</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">params</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="k">unless</span> <span class="n">params</span><span class="o">[</span><span class="ss">:when</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:later</span>
      <span class="n">output</span><span class="p">(</span><span class="n">options</span><span class="o">[</span><span class="ss">:message</span><span class="o">]</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>不要在条件表达式里使用 <code>=</code> （赋值）的返回值。</p>

<div class="highlight">
<pre><span class="c1"># å·® (è¿ä¼æä¸ªè­¦å)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">grep</span><span class="p">(</span><span class="sr">/foo/</span><span class="p">))</span>
  <span class="n">do_something</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>

<span class="c1"># å·® (è¿ä¼æä¸ªè­¦å)</span>
<span class="k">if</span> <span class="n">v</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">grep</span><span class="p">(</span><span class="sr">/foo/</span><span class="p">)</span>
  <span class="n">do_something</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">grep</span><span class="p">(</span><span class="sr">/foo/</span><span class="p">)</span>
<span class="k">if</span> <span class="n">v</span>
  <span class="n">do_something</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>放心地使用 <code>||=</code> 来初始化变量</p>

<div class="highlight">
<pre><span class="c1"># ä»å¨ name ä¸º nil æ false æ¶ï¼æåå­è®¾ä¸º Bozhidarã</span>
<span class="nb">name</span> <span class="o">||=</span> <span class="s1">'Bozhidar'</span>
</pre>
</div>
</li>
<li>
<p>不要使用 <code>||=</code> 来初始化布尔变量。 （想看看如果现在的值刚好是 <code>false</code> 时会发生什么。）</p>

<div class="highlight">
<pre><span class="c1"># å·® â ä¼æ enabled è®¾æçï¼å³ä¾¿å®æ¬æ¥æ¯åã</span>
<span class="n">enabled</span> <span class="o">||=</span> <span class="kp">true</span>

<span class="c1"># å¥½</span>
<span class="n">enabled</span> <span class="o">=</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">enabled</span><span class="o">.</span><span class="n">nil?</span>
</pre>
</div>
</li>
<li><p>避免使用 Perl 风格的特殊变量（像是 <code>$0-9</code>, <code>$</code>, 等等）。它们看起来非常神秘而不鼓励使用，除非用于单行脚本。</p></li>
<li>
<p>永远不要在方法名与左括号之间放一个空格。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">f</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1"># å¥½</span>
<span class="n">f</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre>
</div>
</li>
<li><p>如果方法的第一个参数由左括号开始的，则此方法调用应该使用括号。举个例子，如 <code>f((3+2) + 1)</code>。</p></li>
<li><p>总是使用 <code>-w</code> 来执行 Ruby 解释器，如果你忘了某个上述的规则，它就会警告你！</p></li>
<li>
<p>使用新的 lambda 字面语法。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="nb">lambda</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span>
<span class="nb">lambda</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># å¥½</span>
<span class="nb">lambda</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span>
<span class="nb">lambda</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre>
</div>
</li>
<li>
<p>未使用的区块参数使用 <code>_</code> 。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">result</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>

<span class="c1"># å¥½</span>
<span class="n">result</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</pre>
</div>
</li>
<li><p>使用 <code>$stdout/$stderr/$stdin</code> 而不是
<code>STDOUT/STDERR/STDIN</code>。<code>STDOUT/STDERR/STDIN</code> 是常量，而在 Ruby 中，
当你实际需要给常量重新复制（可能是重定向到某个流），只要你这样做你就
会从解释器得到一个警告。</p></li>
<li><p>使用 <code>warn</code> 而不是 <code>$stderr.puts</code>。除了更加清晰简洁，如果你需要的话，
<code>warn</code> 还允许你压制（suppress）警告（通过<code>-W0</code>将警告级别设为0）。</p></li>
<li>
<p>倾向使用 <code>sprintf</code> 而不是相当隐晦的 <code>String#%</code> 方法.</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="s1">'%d %d'</span> <span class="o">%</span> <span class="o">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="o">]</span>
<span class="c1"># =&gt; '20 10'</span>

<span class="c1"># å¥½</span>
<span class="nb">sprintf</span><span class="p">(</span><span class="s1">'%d %d'</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1"># =&gt; '20 10'</span>
</pre>
</div>
</li>
<li>
<p>倾向使用 <code>Array#join</code> 而不是相当隐晦的使用字符串作参数的 <code>Array#*</code>。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="sx">%w(one two three)</span> <span class="o">*</span> <span class="s1">', '</span>
<span class="c1"># =&gt; 'one, two, three'</span>

<span class="c1"># å¥½</span>
<span class="sx">%w(one two three)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span>
<span class="c1"># =&gt; 'one, two, three'</span>
</pre>
</div>
</li>
<li>
<p>当处理你希望像 Array 那样对待的变量，但是你不确定它是一个数组时，
使用 <code>[*var]</code> or <code>Array()</code> 而不是显式的 <code>Array</code> 检查。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">paths</span> <span class="o">=</span> <span class="o">[</span><span class="n">paths</span><span class="o">]</span> <span class="k">unless</span> <span class="n">paths</span><span class="o">.</span><span class="n">is_a?</span> <span class="nb">Array</span>
<span class="n">paths</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">path</span><span class="o">|</span> <span class="n">do_something</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">}</span>

<span class="c1"># å¥½</span>
<span class="o">[*</span><span class="n">paths</span><span class="o">].</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">path</span><span class="o">|</span> <span class="n">do_something</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">}</span>

<span class="c1"># å¥½ï¼èä¸æ´å·æè¯»æ§ä¸ç¹ï¼</span>
<span class="nb">Array</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">path</span><span class="o">|</span> <span class="n">do_something</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">}</span>
</pre>
</div>
</li>
<li>
<p>如果可能，使用范围来替换复杂的逻辑比较。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">do_something</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1000</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2000</span>

<span class="c1"># å¥½</span>
<span class="n">do_something</span> <span class="k">if</span> <span class="p">(</span><span class="mi">1000</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="mi">2000</span><span class="p">)</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre>
</div>
</li>
</ul>
<h2>命名</h2>
<blockquote>
<p>程式设计的真正难题是替事物命名及使缓存失效。 <br>
-- Phil Karlton</p>
</blockquote>
<ul>
<li>
<p>标识符用英语命名。</p>

<div class="highlight">
<pre><span class="c1"># å·® - åéåç¨å¸¦ææä¸æçä¿å å©äºè¯­åæã</span>
<span class="n">zaplata</span> <span class="o">=</span> <span class="mi">1_000</span>

<span class="c1"># å¥½</span>
<span class="n">salary</span> <span class="o">=</span> <span class="mi">1_000</span>
</pre>
</div>
</li>
<li>
<p>符号、方法与变量使用蛇底式小写（snake_case）。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="ss">:'some symbol'</span>
<span class="ss">:SomeSymbol</span>
<span class="ss">:someSymbol</span>

<span class="n">someVar</span> <span class="o">=</span> <span class="mi">5</span>

<span class="k">def</span> <span class="nf">someMethod</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">SomeMethod</span>
 <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="ss">:some_symbol</span>

<span class="k">def</span> <span class="nf">some_method</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>类别与模组使用驼峰式大小写（CamelCase）。（保留类似 HTTP、RFC、XML 这种缩写为大写）</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">class</span> <span class="nc">Someclass</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Some_Class</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SomeXml</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">class</span> <span class="nc">SomeClass</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SomeXML</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>其他常数使用尖叫蛇底式大写（SCREAMING_SNAKE_CASE）。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="no">SomeConst</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># å¥½</span>
<span class="no">SOME_CONST</span> <span class="o">=</span> <span class="mi">5</span>
</pre>
</div>
</li>
<li><p>判断式方法的名字（返回布尔值的方法）应以问号结尾。 (例如： <code>Array#empty?</code> )</p></li>
<li><p>有潜在 <em>危险性</em> 的方法，若此 <em>危险</em> 方法有安全版本存在时，应以安全版本名加上惊叹号结尾（例如：改动 <code>self</code> 或参数、 <code>exit!</code> 等等方法）。</p></li>
<li>
<p>如果存在潜在的*危险*方法（即修改 <code>self</code> 或者参数的方法，不像 <code>exit</code> 那样运行
finalizers的 <code>exit!</code>，等等）的安全版本，那么*危险*方法的名字应该以惊叹号结尾。</p>

<div class="highlight">
<pre><span class="c1"># ä¸å¥½ - æ²¡æå¯¹åºçå®å¨æ¹æ³</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">update!</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">update</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">update!</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">update</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>如果可能的话，根据危险方法（bang）来定义对应的安全方法（non-bang）。</p>

<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Array</span>
  <span class="k">def</span> <span class="nf">flatten_once!</span>
    <span class="n">res</span> <span class="o">=</span> <span class="o">[]</span>

    <span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
      <span class="o">[*</span><span class="n">e</span><span class="o">].</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="n">replace</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">flatten_once</span>
    <span class="nb">dup</span><span class="o">.</span><span class="n">flatten_once!</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li><p>在短的区块使用 <code>reduce</code> 时，把参数命名为 <code>|a, e|</code> (累加器，元素)</p></li>
<li>
<p>在定义二元操作符时，把参数命名为 <code>other</code> （<code>&lt;&lt;</code> 与 <code>[]</code> 是这条规则的例外，因为它们的语义不同）。</p>

<div class="highlight">
<pre><span class="k">def</span> <span class="nf">+</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="c1"># body omitted</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li><p>倾向使用 <code>map</code> 而不是 <code>collect</code> ， <code>find</code> 而不是 <code>detect</code> ， <code>select</code> 而不是 <code>find_all</code> ， <code>reduce</code> 而不是 <code>inject</code> 以及 <code>size</code> 而不是 <code>length</code> 。这不是一个硬性要求；如果使用别名增加了可读性，使用它没关系。这些有押韵的方法名是从 Smalltalk 继承而来，在别的语言不通用。鼓励使用 <code>select</code> 而不是 <code>find_all</code> 的理由是它跟 <code>reject</code> 搭配起来是一目了然的。</p></li>
<li>
<p>倾向使用 <code>flat_map</code> 而不是 <code>map</code> + <code>flatten</code> 的组合。
这并不适用于深度大于 2 的数组，举个例子，如果 <code>users.first.songs == ['a', ['b', 'c']]</code> ，则使用 <code>map + flatten</code> 的组合，而不是使用 <code>flat_map</code> 。
<code>flat_map</code> 将数组变平坦一个层级，而 <code>flatten</code> 会将整个数组变平坦。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">all_songs</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:songs</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="o">.</span><span class="n">uniq</span>

<span class="c1"># å¥½</span>
<span class="n">all_songs</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">flat_map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:songs</span><span class="p">)</span><span class="o">.</span><span class="n">uniq</span>
</pre>
</div>
</li>
</ul>
<h2>注释</h2>
<blockquote>
<p>良好的代码是最佳的文档。当你要加一个注释时，扪心自问，<br>
"如何改善代码让它不需要注释？" 改善代码然后文档化它们以使之更清楚。<br>
-- Steve McConnell</p>
</blockquote>
<ul>
<li>编写自我解释含义的代码然后忽略这一节的其它部分。我是认真的！</li>
<li>用英语写注释。</li>
<li>在注释的 <code>#</code> 与注释文字之间使用一个空格。</li>
<li>比一个单词长的注释要大写开头并使用标点符号。句号后使用<a href="http://en.wikipedia.org/wiki/Sentence_spacing">一个空格</a>。</li>
<li>
<p>避免冗赘的注释</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># è®¡æ°å¨å ä¸</span>
</pre>
</div>
</li>
<li><p>保持现有的注释是最新的。过时的注解比没有注解还差。
&gt; 好代码就像是好的笑话 - 它不需要解释 <br>
&gt; -- Russ Olsen</p></li>
<li><p>避免替烂代码写注释。重构代码让它们看起来一目了然。 （要嘛就做，要嘛不做― 不要只是试试看。-- Yoda）</p></li>
</ul>
<h3>注解</h3>

<ul>
<li>注解应该直接写在相关代码那行之前。</li>
<li>注解关键字后面，跟着一个冒号及空格，接着是一个描述问题的说明。</li>
<li>
<p>如果需要用多行来描述问题，之后的行要放在 <code>#</code> 号后面并缩排两个空格。</p>

<div class="highlight">
<pre><span class="k">def</span> <span class="nf">bar</span>
  <span class="c1"># FIXME: è¿å¨v3.2.1 çæ¬ä¹åä¼å¼å¸¸å´©æºï¼æè®¸ä¸</span>
  <span class="c1">#   BarBazUtil ççæ¬æ´æ°æå³</span>
  <span class="n">baz</span><span class="p">(</span><span class="ss">:quux</span><span class="p">)</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>在问题是显而易见的情况下，任何的文档会是多余的，注解应放在有问题的那行的最后，并且不需更多说明。这个用法应该是例外而不是规则。</p>

<div class="highlight">
<pre><span class="k">def</span> <span class="nf">bar</span>
  <span class="nb">sleep</span> <span class="mi">100</span> <span class="c1"># OPTIMIZE</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li><p>使用 <code>TODO</code> 来标记以后应被加入的未实现特征与功能。</p></li>
<li><p>使用 <code>FIXME</code> 来标记一个需要修复的会引起错误的代码。</p></li>
<li><p>使用 <code>OPTIMIZE</code> 来标记可能影响性能的缓慢或效率低下的代码。</p></li>
<li><p>使用 <code>HACK</code> 来标记代码异味，其中包含了可疑的编码实践以及应该需要重构。</p></li>
<li><p>使用 <code>REVIEW</code> 来标记任何需要审查及确认正常动作的地方。举例来说： <code>REVIEW: 我们确定用户现在是这么做的吗？</code></p></li>
<li><p>如果你觉得恰当的话，可以使用其他定制的注解关键字，但记得把它们文档化在项目的 <code>README</code> 或类似的地方。</p></li>
</ul>
<h2>类与模块</h2>

<ul>
<li>
<p>在类别定义里使用一致的结构。</p>

<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Person</span>
  <span class="c1"># é¦åæ¯ extend ä¸ include</span>
  <span class="kp">extend</span> <span class="no">SomeModule</span>
  <span class="kp">include</span> <span class="no">AnotherModule</span>

  <span class="c1"># æ¥çæ¯å¸¸é</span>
  <span class="no">SOME_CONSTANT</span> <span class="o">=</span> <span class="mi">20</span>

  <span class="c1"># æ¥ä¸æ¥æ¯å±æ§å®</span>
  <span class="kp">attr_reader</span> <span class="ss">:name</span>

  <span class="c1"># è·çæ¯å¶å®çå®ï¼å¦ææçè¯ï¼</span>
  <span class="n">validates</span> <span class="ss">:name</span>

  <span class="c1"># å¬å¼çç±»å«æ¹æ³æ¥å¨ä¸ä¸è¡</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">some_method</span>
  <span class="k">end</span>

  <span class="c1"># è·çæ¯å¬å¼çå®ä¾æ¹æ³</span>
  <span class="k">def</span> <span class="nf">some_method</span>
  <span class="k">end</span>

  <span class="c1"># åä¿æ¤åç§æçæ¹æ³ï¼ä¸èµ·æ¾å¨æ¥è¿ç»å°¾çå°æ¹</span>
  <span class="kp">protected</span>

  <span class="k">def</span> <span class="nf">some_protected_method</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">some_private_method</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>倾向使用模块，而不是只有类别方法的类。类别应该只在产生实例是合理的时候使用。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">class</span> <span class="nc">SomeClass</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">some_method</span>
    <span class="c1"># çç¥å½æ°ä½</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">some_other_method</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">module</span> <span class="nn">SomeClass</span>
  <span class="kp">module_function</span>

  <span class="k">def</span> <span class="nf">some_method</span>
    <span class="c1"># çç¥å½æ°ä½</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">some_other_method</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>当你想将模块的实例方法变成类别方法时，偏爱使用 <code>module_function</code> 胜过 <code>extend self</code> 。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">module</span> <span class="nn">Utilities</span>
  <span class="kp">extend</span> <span class="nb">self</span>

  <span class="k">def</span> <span class="nf">parse_something</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="c1"># åä¸äºäº</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">other_utility_method</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
    <span class="c1"># åå¦ä¸äºäº</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">module</span> <span class="nn">Utilities</span>
  <span class="kp">module_function</span>

  <span class="k">def</span> <span class="nf">parse_something</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="c1"># åä¸äºäº</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">other_utility_method</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
    <span class="c1"># åå¦ä¸äºäº</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li><p>当设计类型层级时，确认它们符合<a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov 替换原则</a>。</p></li>
<li><p>尽可能让你的类型越<a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a>越好。</p></li>
<li>
<p>永远替类型提供一个适当的 <code>to_s</code> 方法给来表示领域模型。</p>

<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">attr_reader</span> <span class="ss">:first_name</span><span class="p">,</span> <span class="ss">:last_name</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span>
    <span class="vi">@first_name</span> <span class="o">=</span> <span class="n">first_name</span>
    <span class="vi">@last_name</span> <span class="o">=</span> <span class="n">last_name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="s2">"</span><span class="si">#{</span><span class="vi">@first_name</span> <span class="c1">#@last_name"}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>使用 <code>attr</code> 系列函数来定义琐碎的 accessor 或 mutators。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span>
    <span class="vi">@first_name</span> <span class="o">=</span> <span class="n">first_name</span>
    <span class="vi">@last_name</span> <span class="o">=</span> <span class="n">last_name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">first_name</span>
    <span class="vi">@first_name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">last_name</span>
    <span class="vi">@last_name</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">attr_reader</span> <span class="ss">:first_name</span><span class="p">,</span> <span class="ss">:last_name</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span>
    <span class="vi">@first_name</span> <span class="o">=</span> <span class="n">first_name</span>
    <span class="vi">@last_name</span> <span class="o">=</span> <span class="n">last_name</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>考虑使用 <code>Struct.new</code>，它替你定义了那些琐碎的存取器（accessors），构造器（constructor）以及比较操作符（comparison operators）。</p>

<div class="highlight">
<pre><span class="c1"># å¥½</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">attr_reader</span> <span class="ss">:first_name</span><span class="p">,</span> <span class="ss">:last_name</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span>
    <span class="vi">@first_name</span> <span class="o">=</span> <span class="n">first_name</span>
    <span class="vi">@last_name</span> <span class="o">=</span> <span class="n">last_name</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># æ´å¥½</span>
<span class="no">Person</span> <span class="o">=</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">,</span> <span class="ss">:last_name</span><span class="p">)</span> <span class="k">do</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>考虑加入工厂方法以提供附加的有意义的方式来生成一个特定的类实例。</p>

<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">create</span><span class="p">(</span><span class="n">options_hash</span><span class="p">)</span>
    <span class="c1"># body omitted</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>倾向使用<a href="http://en.wikipedia.org/wiki/Duck_typing">Duck Typing</a>而不是继承。</p>

<div class="highlight">
<pre><span class="c1">## å·®</span>
<span class="k">class</span> <span class="nc">Animal</span>
  <span class="c1"># æ½è±¡æ¹æ³</span>
  <span class="k">def</span> <span class="nf">speak</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># ç»§æ¿è¶ç±»</span>
<span class="k">class</span> <span class="nc">Duck</span> <span class="o">&lt;</span> <span class="no">Animal</span>
  <span class="k">def</span> <span class="nf">speak</span>
    <span class="nb">puts</span> <span class="s1">'Quack! Quack'</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># ç»§æ¿è¶ç±»</span>
<span class="k">class</span> <span class="nc">Dog</span> <span class="o">&lt;</span> <span class="no">Animal</span>
  <span class="k">def</span> <span class="nf">speak</span>
    <span class="nb">puts</span> <span class="s1">'Bau! Bau!'</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1">## å¥½</span>
<span class="k">class</span> <span class="nc">Duck</span>
  <span class="k">def</span> <span class="nf">speak</span>
    <span class="nb">puts</span> <span class="s1">'Quack! Quack'</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Dog</span>
  <span class="k">def</span> <span class="nf">speak</span>
    <span class="nb">puts</span> <span class="s1">'Bau! Bau!'</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>由于类变量在继承中产生的 "讨厌的" 行为，避免使用类变量( <code>@@</code> )。</p>

<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Parent</span>
  <span class="vc">@@class_var</span> <span class="o">=</span> <span class="s1">'parent'</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">print_class_var</span>
    <span class="nb">puts</span> <span class="vc">@@class_var</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="o">&lt;</span> <span class="no">Parent</span>
  <span class="vc">@@class_var</span> <span class="o">=</span> <span class="s1">'child'</span>
<span class="k">end</span>

<span class="no">Parent</span><span class="o">.</span><span class="n">print_class_var</span> <span class="c1"># =&gt; will print "child"</span>
</pre>
</div>


<p>如同你所看到的，在类型层级中的所有类其实都共享单独一个类变量。通常情况下应该倾向使用实例变量而不是类变量。</p>
</li>
<li><p>依据方法的目的用途指定适当的可见层级(<code>private</code> ,<code>protected</code> )。别把所有方法都设为 <code>public</code> （方法的缺省值）。我们现在是在写 <em>Ruby</em> ，不是 <em>Python</em> 。</p></li>
<li>
<p>将 <code>public</code>，<code>protected</code>，<code>private</code> 和被应用的方法定义保持一致的缩排。在上下各留一行来强调这个可见性应用于之后的所有方法。）</p>

<div class="highlight">
<pre><span class="k">class</span> <span class="nc">SomeClass</span>
  <span class="k">def</span> <span class="nf">public_method</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">private_method</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">another_private_method</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>使用<code>def self.method</code> 来定义 singleton 方法。由于类的名称不会重复的关系，这使得代码更容易重构。</p>

<div class="highlight">
<pre><span class="k">class</span> <span class="nc">TestClass</span>
  <span class="c1"># å·®</span>
  <span class="k">def</span> <span class="nc">TestClass</span><span class="o">.</span><span class="nf">some_method</span>
    <span class="c1"># çç¥æ¹æ³ä½</span>
  <span class="k">end</span>

  <span class="c1"># å¥½</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">some_other_method</span>
    <span class="c1"># çç¥æ¹æ³ä½</span>
  <span class="k">end</span>

  <span class="c1"># ä¹æå¯è½åå½ä½ è¦å®ä¹å¤ä¸ª</span>
  <span class="c1"># singletonæ¶çä¾¿å©æ¹æ³</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">first_method</span>
      <span class="c1"># çç¥æ¹æ³ä½</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">second_method_etc</span>
      <span class="c1"># çç¥æ¹æ³ä½</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
</ul>
<h2>异常</h2>

<ul>
<li>
<p>使用 <code>fail</code> 方法来抛出异常。仅在捕捉到异常时使用 <code>raise</code> 来重新抛出异常（因为没有失败，所以只是显式地有目的性地抛出一个异常）</p>

<div class="highlight">
<pre><span class="k">begin</span>
 <span class="nb">fail</span> <span class="s1">'Oops'</span><span class="p">;</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">error</span>
  <span class="k">raise</span> <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">message</span> <span class="o">!=</span> <span class="s1">'Oops'</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>永远不要从 <code>ensure</code> 区块返回。如果你显式地从 <code>ensure</code> 区块中的一个方法返回，那么这方法会如同没有异常般的返回。实际上，异常会被默默丢掉。</p>

<div class="highlight">
<pre><span class="k">def</span> <span class="nf">foo</span>
  <span class="k">begin</span>
    <span class="nb">fail</span>
  <span class="k">ensure</span>
    <span class="k">return</span> <span class="s1">'very bad idea'</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>尽可能使用隐式的 <code>begin</code> 区块。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">def</span> <span class="nf">foo</span>
  <span class="k">begin</span>
    <span class="c1"># æ­¤å¤æ¾ä¸»è¦é»è¾</span>
  <span class="k">rescue</span>
    <span class="c1"># éè¯¯å¤çæ¾å¨æ­¤å¤</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">def</span> <span class="nf">foo</span>
  <span class="c1"># æ­¤å¤æ¾ä¸»è¦é»è¾</span>
<span class="k">rescue</span>
  <span class="c1"># éè¯¯å¤çæ¾å¨æ­¤å¤</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>通过 <em>contingency</em> 方法 (一个由 Avdi Grimm 创造的词)来减少 <code>begin</code> 区块的使用。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">begin</span>
  <span class="n">something_that_might_fail</span>
<span class="k">rescue</span> <span class="no">IOError</span>
  <span class="c1"># å¤ç IOError</span>
<span class="k">end</span>

<span class="k">begin</span>
  <span class="n">something_else_that_might_fail</span>
<span class="k">rescue</span> <span class="no">IOError</span>
  <span class="c1"># å¤ç IOError</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">def</span> <span class="nf">with_io_error_handling</span>
   <span class="k">yield</span>
<span class="k">rescue</span> <span class="no">IOError</span>
  <span class="c1"># å¤ç IOError</span>
<span class="k">end</span>

<span class="n">with_io_error_handling</span> <span class="p">{</span> <span class="n">something_that_might_fail</span> <span class="p">}</span>

<span class="n">with_io_error_handling</span> <span class="p">{</span> <span class="n">something_else_that_might_fail</span> <span class="p">}</span>
</pre>
</div>
</li>
<li>
<p>不要封锁异常。</p>

<div class="highlight">
<pre><span class="k">begin</span>
  <span class="c1"># è¿éåçäºä¸ä¸ªå¼å¸¸</span>
<span class="k">rescue</span> <span class="no">SomeError</span>
  <span class="c1"># æ¯æå­å¥å®å¨æ²¡æåäº</span>
<span class="k">end</span>

<span class="c1"># å·®</span>
<span class="n">do_something</span> <span class="k">rescue</span> <span class="kp">nil</span>
</pre>
</div>
</li>
<li>
<p>避免使用 <code>rescue</code> 的修饰符形式。</p>

<div class="highlight">
<pre><span class="c1"># å·® - è¿ææäºææç StandardError å¼å¸¸ã</span>
<span class="n">do_something</span> <span class="k">rescue</span> <span class="kp">nil</span>
</pre>
</div>
</li>
<li>
<p>不要为了控制流程而使用异常。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">begin</span>
  <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>
<span class="k">rescue</span> <span class="no">ZeroDivisionError</span>
  <span class="nb">puts</span> <span class="s1">'Cannot divide by 0!'</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">zero?</span>
  <span class="nb">puts</span> <span class="s1">'Cannot divide by 0!'</span>
<span class="k">else</span>
  <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>避免救援 <code>Exception</code> 类别。这会把信号困住，并呼叫 <code>exit</code>，导致你需要 <code>kill -9</code> 进程。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">begin</span>
  <span class="c1"># å¼å« exit åææä¿¡å·ä¼è¢«ææï¼é¤äº kill -9ï¼</span>
  <span class="nb">exit</span>
<span class="k">rescue</span> <span class="no">Exception</span>
  <span class="nb">puts</span> <span class="s2">"you didn't really want to exit, right?"</span>
  <span class="c1"># å¼å¸¸å¤ç</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">begin</span>
  <span class="c1"># ä¸ä¸ªä¸æç¡®çrescueå­å¥ææçæ¯StandardErrorï¼</span>
  <span class="c1">#   èä¸æ¯è®¸å¤ç¼ç¨èæè®¾æ³çExceptionã</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># å¼å¸¸å¤ç</span>
<span class="k">end</span>

<span class="c1"># ä¹å¥½</span>
<span class="k">begin</span>
  <span class="c1"># è¿éåçä¸ä¸ªå¼å¸¸</span>

<span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># å¼å¸¸å¤ç</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>把较具体的异常放在救援串连的较上层，不然它们永远不会被拯救。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">begin</span>
  <span class="c1"># ä¸äºä»£ç </span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># ä¸äºå¤ç</span>
<span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># ä¸äºå¤ç</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">begin</span>
  <span class="c1"># ä¸äºä»£ç </span>
<span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># ä¸äºå¤ç</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># ä¸äºå¤ç</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>在 ensure 区块中释放你的程式的外部资源。</p>

<div class="highlight">
<pre><span class="n">f</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">'testfile'</span><span class="p">)</span>
<span class="k">begin</span>
  <span class="c1"># .. å¤ç</span>
<span class="k">rescue</span>
  <span class="c1"># .. éè¯¯å¤ç</span>
<span class="k">ensure</span>
  <span class="n">f</span><span class="o">.</span><span class="n">close</span> <span class="k">unless</span> <span class="n">f</span><span class="o">.</span><span class="n">nil?</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li><p>倾向使用标准库的异常类而不是导入新的异常类。</p></li>
</ul>
<h2>集合</h2>

<ul>
<li>
<p>倾向数组及哈希的字面表示法（除非你需要给构造器传入参数）。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">arr</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span>
<span class="nb">hash</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span>

<span class="c1"># å¥½</span>
<span class="n">arr</span> <span class="o">=</span> <span class="o">[]</span>
<span class="nb">hash</span> <span class="o">=</span> <span class="p">{}</span>
</pre>
</div>
</li>
<li>
<p>对字面数组语法，当你需要一个单词（没有空格和特殊字符的非空字符串）的数组时，
倾向使用 <code>%w</code>。仅当数组只有两个及以上元素时才应用这个规则。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="no">STATES</span> <span class="o">=</span> <span class="o">[</span><span class="s1">'draft'</span><span class="p">,</span> <span class="s1">'open'</span><span class="p">,</span> <span class="s1">'closed'</span><span class="o">]</span>

<span class="c1"># å¥½</span>
<span class="no">STATES</span> <span class="o">=</span> <span class="sx">%w(draft open closed)</span>
</pre>
</div>
</li>
<li>
<p>对字面数组语法，当你需要一个符号（并且不需要保持 Ruby 1.9 兼容性）的数组时，
倾向使用 <code>%i</code>。仅当数组只有两个及以上元素时才应用这个规则。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="no">STATES</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:draft</span><span class="p">,</span> <span class="ss">:open</span><span class="p">,</span> <span class="ss">:closed</span><span class="o">]</span>

<span class="c1"># å¥½</span>
<span class="no">STATES</span> <span class="o">=</span> <span class="o">%</span><span class="n">i</span><span class="p">(</span><span class="n">draft</span> <span class="nb">open</span> <span class="n">closed</span><span class="p">)</span>
</pre>
</div>
</li>
<li>
<p>避免在数组中创造巨大的间隔。</p>

<div class="highlight">
<pre><span class="n">arr</span> <span class="o">=</span> <span class="o">[]</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">100</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># ç°å¨ä½ æä¸ä¸ªå¾å¤ nil çæ°ç»</span>
</pre>
</div>
</li>
<li><p>当处理独一无二的元素时，使用 <code>Set</code> 来替代 <code>Array</code> 。 <code>Set</code> 实现了不重复的无序数值集合。 <code>Set</code>是数组直观的内部操作功能与哈希的快速存取的混合体。</p></li>
<li>
<p>倾向用符号来取代字符串作为哈希的键。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">'one'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'two'</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'three'</span> <span class="o">=&gt;</span> <span class="mi">3</span> <span class="p">}</span>

<span class="c1"># å¥½</span>
<span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span> <span class="n">one</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span>
</pre>
</div>
</li>
<li><p>避免使用可变的对象作为键值。</p></li>
<li>
<p>当哈希的键为符号时，使用哈希的字面语法。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:one</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">:two</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">:three</span> <span class="o">=&gt;</span> <span class="mi">3</span> <span class="p">}</span>

<span class="c1"># å¥½</span>
<span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span> <span class="n">one</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span>
</pre>
</div>
</li>
<li>
<p>在处理应该存在的哈希键时，使用<code>fetch</code> 。</p>

<div class="highlight">
<pre><span class="n">heroes</span> <span class="o">=</span> <span class="p">{</span> <span class="n">batman</span><span class="p">:</span> <span class="s1">'Bruce Wayne'</span><span class="p">,</span> <span class="n">superman</span><span class="p">:</span> <span class="s1">'Clark Kent'</span> <span class="p">}</span>
<span class="c1"># å·® - å¦ææä»¬æéå­çè¯ï¼æä»¬å°±æ æ³æ¾å°å¯¹çè±éäº</span>
<span class="n">heroes</span><span class="o">[</span><span class="ss">:batman</span><span class="o">]</span> <span class="c1"># =&gt; "Bruce Wayne"</span>
<span class="n">heroes</span><span class="o">[</span><span class="ss">:supermen</span><span class="o">]</span> <span class="c1"># =&gt; nil</span>

<span class="c1"># å¥½ - fetch ä¼æåºä¸ä¸ª KeyError æ¥ä½¿è¿ä¸ªé®é¢ææ¾</span>
<span class="n">heroes</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:supermen</span><span class="p">)</span>
</pre>
</div>
</li>
<li><p>在使用 <code>fetch</code> 时，使用第二个参数设置默认值</p></li>
</ul>
<div class="highlight">
<pre>   <span class="n">batman</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">name</span><span class="p">:</span> <span class="s1">'Bruce Wayne'</span><span class="p">,</span> <span class="n">is_evil</span><span class="p">:</span> <span class="kp">false</span> <span class="p">}</span>

   <span class="c1"># å·® - å¦ææä»¬ä»ä»ä½¿ç¨ || æä½ç¬¦ï¼é£ä¹å½å¼ä¸ºåæ¶ï¼æä»¬ä¸ä¼å¾å°é¢æçç»æ</span>
   <span class="n">batman</span><span class="o">[</span><span class="ss">:is_evil</span><span class="o">]</span> <span class="o">||</span> <span class="kp">true</span> <span class="c1"># =&gt; true</span>

   <span class="c1"># å¥½ - fetch å¨éå°åå¼æ¶ä¾ç¶æ­£ç¡®</span>
   <span class="n">batman</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:is_evil</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span> <span class="c1"># =&gt; false</span>
</pre>
</div>


<ul>
<li>依赖这个事实， Ruby 1.9 的哈希是有序的。</li>
<li>在遍历一个集合时，不要改动它。</li>
</ul>
<h2>字符串</h2>

<ul>
<li>
<p>倾向使用字符串插值（interpolation），而不是字符串连接（concatenation）。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="n">email_with_name</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">' &lt;'</span> <span class="o">+</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="o">+</span> <span class="s1">'&gt;'</span>

<span class="c1"># å¥½</span>
<span class="n">email_with_name</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> &lt;</span><span class="si">#{</span><span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="si">}</span><span class="s2">&gt;"</span>
</pre>
</div>
</li>
<li>
<p>考虑替字符串插值留白。這使插值在字符串里看起來更清楚。</p>

<div class="highlight">
<pre><span class="s2">"</span><span class="si">#{</span> <span class="n">user</span><span class="o">.</span><span class="n">last_name</span> <span class="si">}</span><span class="s2">, </span><span class="si">#{</span> <span class="n">user</span><span class="o">.</span><span class="n">first_name</span> <span class="si">}</span><span class="s2">"</span>
</pre>
</div>
</li>
<li>
<p>当你不需要插入特殊符号如 <code>\t</code>, <code>\n</code>, <code>'</code>, 等等时，倾向使用单引号的字符串。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="nb">name</span> <span class="o">=</span> <span class="s2">"Bozhidar"</span>

<span class="c1"># å¥½</span>
<span class="nb">name</span> <span class="o">=</span> <span class="s1">'Bozhidar'</span>
</pre>
</div>
</li>
<li>
<p>别忘了使用 <code>{}</code> 来围绕被插入字符串的实例与全局变量。</p>

<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">attr_reader</span> <span class="ss">:first_name</span><span class="p">,</span> <span class="ss">:last_name</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span>
    <span class="vi">@first_name</span> <span class="o">=</span> <span class="n">first_name</span>
    <span class="vi">@last_name</span> <span class="o">=</span> <span class="n">last_name</span>
  <span class="k">end</span>

  <span class="c1"># å·® - ææï¼ä½é¾ç</span>
  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="s2">"</span><span class="si">#@first_name</span><span class="s2"> </span><span class="si">#@last_name</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="c1"># å¥½</span>
  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="s2">"</span><span class="si">#{</span><span class="vi">@first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="vi">@last_name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="vg">$global</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># å·®</span>
<span class="nb">puts</span> <span class="s2">"$global = </span><span class="si">#$global</span><span class="s2">"</span>

<span class="c1"># å¥½</span>
<span class="nb">puts</span> <span class="s2">"$global = </span><span class="si">#{</span><span class="vg">$global</span><span class="si">}</span><span class="s2">"</span>
</pre>
</div>
</li>
<li>
<p>当你需要建构庞大的数据块（chunk）时，避免使用 <code>String#+</code> 。
使用 <code>String#&lt;&lt;</code> 来替代。字符串用<code>&lt;&lt;</code>连接能就地改变字符串实例，并且永远比 <code>String#+</code> 来得快，<code>String#+</code> 创造了一堆新的字符串对象。</p>

<div class="highlight">
<pre><span class="c1"># å¥½ä¹æ¯è¾å¿«</span>
<span class="n">html</span> <span class="o">=</span> <span class="s1">''</span>
<span class="n">html</span> <span class="o">&lt;&lt;</span> <span class="s1">'&lt;h1&gt;Page title&lt;/h1&gt;'</span>

<span class="n">paragraphs</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">paragraph</span><span class="o">|</span>
  <span class="n">html</span> <span class="o">&lt;&lt;</span> <span class="s2">"&lt;p&gt;</span><span class="si">#{</span><span class="n">paragraph</span><span class="si">}</span><span class="s2">&lt;/p&gt;"</span>
<span class="k">end</span>
</pre>
</div>
</li>
</ul>
<h2>正则表达式</h2>
<blockquote>
<p>有些人在面对问题时，不经大脑便认为，「我知道，这里该用正则表达式」。现在问题反倒变成两个了。<br>
-- Jamie Zawinski</p>
</blockquote>
<ul>
<li>如果你只需要在字符串中简单的搜索文字，不要使用正则表达式：<code>string['text']</code>
</li>
<li>
<p>针对简单的字符串查询，你可以直接在字符串索引中直接使用正则表达式。</p>

<div class="highlight">
<pre><span class="n">match</span> <span class="o">=</span> <span class="n">string</span><span class="o">[</span><span class="sr">/regexp/</span><span class="o">]</span> <span class="c1"># è·å¾å¹éæ­£åè¡¨è¾¾å¼çåå®¹</span>
<span class="n">first_group</span> <span class="o">=</span> <span class="n">string</span><span class="o">[</span><span class="sr">/text(grp)/</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span> <span class="c1"># æå¾åç»çåå®¹</span>
<span class="n">string</span><span class="o">[</span><span class="sr">/text (grp)/</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="s1">'replace'</span> <span class="c1"># string =&gt; 'text replace'</span>
</pre>
</div>
</li>
<li>
<p>当你不需要替结果分组时，使用非分组的群组。</p>

<div class="highlight">
<pre><span class="sr">/(first|second)/</span> <span class="c1"># å·®</span>
<span class="sr">/(?:first|second)/</span> <span class="c1"># å¥½</span>
</pre>
</div>
</li>
<li>
<p>避免使用 <code>$1-9</code>，因为它们很难追踪它们包含什么。可以使用命名群组来替代。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="sr">/(regexp)/</span> <span class="o">=~</span> <span class="n">string</span>
<span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="n">process</span> <span class="vg">$1</span>

<span class="c1"># å¥½</span>
<span class="sr">/(?&lt;meaningful_var&gt;regexp)/</span> <span class="o">=~</span> <span class="n">string</span>
<span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="n">process</span> <span class="n">meaningful_var</span>
</pre>
</div>
</li>
<li><p>字符类别只有几个你需要关心的特殊字符：<code>^</code>, <code>-</code>, <code>\</code>, <code>]</code>，所以你不用转义字<code>.</code> 或 <code>[]</code> 的中括号。</p></li>
<li>
<p>小心使用 <code>^</code> 与 <code>$</code> ，它们匹配的是一行的开始与结束，不是字符串的开始与结束。如果你想要匹配整个字符串，使用 <code>\A</code> 与 <code>\z</code>。(译注：<code>\Z</code> 实为 <code>/\n?\z/</code>，使用 <code>\z</code> 才能匹配到有含新行的字符串的结束)</p>

<div class="highlight">
<pre><span class="n">string</span> <span class="o">=</span> <span class="s2">"some injection</span><span class="se">\n</span><span class="s2">username"</span>
<span class="n">string</span><span class="o">[</span><span class="sr">/^username$/</span><span class="o">]</span> <span class="c1"># å¹é</span>
<span class="n">string</span><span class="o">[</span><span class="sr">/\Ausername\z/</span><span class="o">]</span> <span class="c1"># ä¸å¹é</span>
</pre>
</div>
</li>
<li>
<p>针对复杂的正则表达式，使用 <code>x</code> 修饰符。这让它们的可读性更高并且你可以加入有用的注释。只是要小心忽略的空白。</p>

<div class="highlight">
<pre><span class="n">regexp</span> <span class="o">=</span> <span class="sr">%r{</span>
<span class="sr">  start # ä¸äºæå­</span>
<span class="sr">  \s # ç©ºç½å­å</span>
<span class="sr">  (group) # ç¬¬ä¸ç»</span>
<span class="sr">  (?:alt1|alt2) # ä¸äºæ¿ä»£æ¹æ¡</span>
<span class="sr">  end</span>
<span class="sr">}x</span>
</pre>
</div>
</li>
<li><p>针对复杂的替换，<code>sub</code> 或 <code>gsub</code> 可以与区块或哈希来使用。</p></li>
</ul>
<h2>百分比字面</h2>

<ul>
<li>
<p>使用 <code>%()</code> 给需要插值与嵌入双引号的单行字符串。多行字符串，倾向使用 heredocs 。</p>

<div class="highlight">
<pre><span class="c1"># å·®ï¼ä¸éè¦æå¼ï¼</span>
<span class="sx">%(&lt;div class="text"&gt;Some text&lt;/div&gt;)</span>
<span class="c1"># åºè¯¥ä½¿ç¨'&lt;div class="text"&gt;Some text&lt;/div&gt;'</span>

<span class="c1"># å·®ï¼æ²¡æåå¼å·ï¼</span>
<span class="sx">%(This is </span><span class="si">#{</span><span class="n">quality</span><span class="si">}</span><span class="sx"> style)</span>
<span class="c1"># åºè¯¥ä½¿ç¨ "This is #{quality} style"</span>

<span class="c1"># å·®ï¼å¤è¡ï¼</span>
<span class="sx">%(&lt;div&gt;</span><span class="se">\n</span><span class="sx">&lt;span class="big"&gt;</span><span class="si">#{</span><span class="n">exclamation</span><span class="si">}</span><span class="sx">&lt;/span&gt;</span><span class="se">\n</span><span class="sx">&lt;/div&gt;)</span>
<span class="c1"># åºè¯¥æ¯ä¸ä¸ª heredoc</span>

<span class="c1"># å¥½ï¼éè¦æå¼ãæåå¼å·ä»¥ååè¡ï¼</span>
<span class="sx">%(&lt;tr&gt;&lt;td class="name"&gt;</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sx">&lt;/td&gt;)</span>
</pre>
</div>
</li>
<li>
<p>正则表达式要匹配多于一个的 <code>/</code> 字元时，使用 <code>%r</code>。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="sr">%r(\s+)</span>

<span class="c1"># ä»ç¶å·®</span>
<span class="sr">%r(^/(.*)$)</span>
<span class="c1"># åºå½æ¯ /^\/(.*)$/</span>

<span class="c1"># å¥½</span>
<span class="sr">%r(^/blog/2011/(.*)$)</span>
</pre>
</div>
</li>
<li><p>避免 <code>%q</code>, <code>%Q</code>, <code>%x</code>, <code>%s</code> 以及 <code>%W</code>。</p></li>
<li><p>倾向使用 <code>()</code> 作为所有 <code>%</code> 字面的分隔符。</p></li>
</ul>
<h2>元编程</h2>

<ul>
<li><p>避免无谓的元编程。</p></li>
<li><p>写一个函数库时不要使核心类混乱（不要使用 monkey patch）。</p></li>
<li>
<p>倾向使用区块形式的 <code>class_eval</code> 而不是字符串插值(string-interpolated)的形式。</p>

<ul>
<li>当你使用字符串插值形式时，总是提供 <code>__FILE__</code> 及 <code>__LINE__</code>，使你的 backtrace 看起来有意义：</li>
</ul>
<div class="highlight">
<pre><span class="nb">class_eval</span> <span class="s2">"def use_relative_model_naming?; true; end"</span><span class="p">,</span> <span class="bp">__FILE__</span><span class="p">,</span> <span class="bp">__LINE__</span>
</pre>
</div>


<ul>
<li>倾向使用 <code>define_method</code> 而不是 <code>class_eval{ def ... }</code>
</li>
</ul>
</li>
<li>
<p>当使用 <code>class_eval</code> （或其它的<code>eval</code>）搭配字符串插值时，添加一个注解区块，来演示如果做了插值的样子（我从 Rails 代码学来的一个实践）：</p>

<div class="highlight">
<pre><span class="c1"># activesupport/lib/active_support/core_ext/string/output_safety.rb</span>
<span class="no">UNSAFE_STRING_METHODS</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">unsafe_method</span><span class="o">|</span>
  <span class="k">if</span> <span class="s1">'String'</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="n">unsafe_method</span><span class="p">)</span>
    <span class="nb">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">EOT</span><span class="p">,</span> <span class="bp">__FILE__</span><span class="p">,</span> <span class="bp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sh">      def #{unsafe_method}(*args, &amp;block) # def capitalize(*args, &amp;block)</span>
<span class="sh">        to_str.#{unsafe_method}(*args, &amp;block) # to_str.capitalize(*args, &amp;block)</span>
<span class="sh">      end # end</span>

<span class="sh">      def #{unsafe_method}!(*args) # def capitalize!(*args)</span>
<span class="sh">        @dirty = true # @dirty = true</span>
<span class="sh">        super # super</span>
<span class="sh">      end # end</span>
<span class="no">    EOT</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</li>
<li>
<p>元编程避免使用 <code>method_missing</code>。会让 Backtraces 变得很凌乱；行为没有列在 <code>#methods</code> 里；拼错的方法调用可能默默的工作（<code>nukes.launch_state = false</code>)。考虑使用 delegation, proxy, 或是 <code>define_method</code> 来取代。如果你必须使用 <code>method_missing</code>，</p>

<ul>
<li>确保<a href="http://blog.marc-andre.ca/2010/11/methodmissing-politely.html">也定义了<code>respond_to_missing?</code></a>
</li>
<li>仅捕捉字首定义良好的方法，像是 <code>find_by_*</code> ― 让你的代码愈肯定(assertive)愈好。</li>
<li>在语句的最后调用 <code>super</code>
</li>
<li>delegate 到确定的、非魔法方法中:</li>
</ul>
<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="k">def</span> <span class="nf">method_missing?</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="sr">/^find_by_(?&lt;prop&gt;.*)/</span> <span class="o">=~</span> <span class="n">meth</span>
    <span class="c1"># ... lots of code to do a find_by</span>
  <span class="k">else</span>
    <span class="k">super</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># å¥½</span>
<span class="k">def</span> <span class="nf">method_missing?</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="sr">/^find_by_(?&lt;prop&gt;.*)/</span> <span class="o">=~</span> <span class="n">meth</span>
    <span class="n">find_by</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="k">super</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># æå¥½çæ¹å¼ï¼å¯è½æ¯æ¯ä¸ªå¯æ¾å°çå±æ§è¢«å£°æåï¼ä½¿ç¨ define_methodã</span>
</pre>
</div>
</li>
</ul>
<h2>其它</h2>

<ul>
<li>
<code>ruby -w</code> 写安全的代码。</li>
<li>避免使用哈希作为可选参数。这个方法是不是做太多事了？（对象初始器是本规则的例外）</li>
<li>避免方法长于 10 行代码（LOC）。理想上，大部分的方法会小于5行。空行不算进LOC里。</li>
<li>避免参数列表长于三或四个参数。</li>
<li>如果你真的需要“全局”方法，把它们加到 Kernel 并设为私有的。</li>
<li>
<p>使用模块变量代替全局变量。</p>

<div class="highlight">
<pre><span class="c1"># å·®</span>
<span class="vg">$foo_bar</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># å¥½</span>
<span class="k">module</span> <span class="nn">Foo</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="kp">attr_accessor</span> <span class="ss">:bar</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">1</span>
</pre>
</div>
</li>
<li><p>当 <code>alias_method</code> 可以做到时，避免使用 <code>alias</code> 。</p></li>
<li><p>使用 <code>OptionParser</code> 来解析复杂的命令行选项及 <code>ruby -s</code> 来处理琐碎的命令行选项。</p></li>
<li><p>用函数式的方法编程，在有意义的情况下避免赋值(mutation)。</p></li>
<li><p>不要改变参数，除非那是方法的目的。</p></li>
<li><p>避免超过三层的区块嵌套。</p></li>
<li><p>保持一致性。在理想的世界里，遵循这些准则。</p></li>
<li><p>使用常识。</p></li>
</ul>
<h2>工具</h2>

<p>以下是一些工具，让你自动检查 Ruby 代码是否符合本指南。</p>

<h3>RuboCop</h3>

<p><a href="https://github.com/bbatsov/rubocop">RuboCop</a> 是一个基于本指南的 Ruby 代码风格检查工具。 RuboCop 涵盖了本指南相当大的部分，支持 MRI 1.9 和 MRI 2.0，而且与 Emacs 整合良好。</p>

<h3>RubyMine</h3>

<p><a href="http://www.jetbrains.com/ruby/">RubyMine</a> 的代码检查是
<a href="http://confluence.jetbrains.com/display/RUBYDEV/RubyMine+Inspections">部分基于</a>
本指南的。</p>

<h1>贡献</h1>

<p>在本指南所写的每个东西都不是定案。这只是我渴望想与同样对 Ruby 编程风格有兴趣的大家一起工作，以致于最终我们可以替整个 Ruby 社区创造一个有益的资源。</p>

<p>欢迎 open tickets 或 push 一个带有改进的更新请求。在此提前感谢你的帮助！</p>

<h1>授权</h1>

<p><img src="http://i.creativecommons.org/l/by/3.0/88x31.png" alt="Creative Commons License">

This work is licensed under a <a href="http://creativecommons.org/licenses/by/3.0/deed.zh">Creative Commons Attribution 3.0 Unported License</a></p>

<h1>口耳相传</h1>

<p>一份社区驱动的风格指南，如果没多少人知道，对一个社区来说就没有多少用处。微博转发这份指南，分享给你的朋友或同事。我们得到的每个评价、建议或意见都可以让这份指南变得更好一点。而我们想要拥有的是最好的指南，不是吗？</p>

<p>共勉之，<br><a href="https://twitter.com/bbatsov">Bozhidar</a></p>
</body>
</html>
